[section `exists()`]

'''
<!--

//          Copyright Michael Shepanski 2014.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file ../../LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

-->
'''

For any query [~q], `exists(`[~q]`)` builds and returns a `predicate` that, when executed, tests whether [~q] produces any output. So it's a wrapper of SQL's keyword =EXISTS=.

[#exists_visibility]
[~q] is allowed to use mappers from the enclosing context.  As [@http://www.postgresql.org/docs/9.3/static/functions-subquery.html the PostgreSQL documentation] explains:

[:The subquery can refer to variables from the surrounding query, which will act as constants during any one evaluation of the subquery.]

I find that the most useful cases tend to take advantage of that; e.g.:

    const query<movie> hall_of_fame =
        movies
        .where(exists(critics.where(critics->favorite_movie == movies->id)));

The query `critics.where(critics->favorite_movie == movies->id)` is not one you could execute by itself, because `movies->id` is not [link expressions.visibility visible] without the context provided by `movies.where(`...`)`.

[#advertise_dependency]
Personally I prefer to break the code up as follows:

    query<critic>
    fans_of(const exprn_mapper<serial> &movie_id) {
        return critics.where(critics->favorite_movie == movie_id);
    }

    const query<movie> hall_of_fame = movies.where(exists(fans_of(movies->id)));

The benefits are:

* the query that needs a context is being generated by a C++ function that advertises the dependency via its argument, and
* that function can be reused at any site that offers such a context.

[endsect]
